{"version":3,"file":"index.modern.js","sources":["../src/MatchResult.js","../src/Route.js","../src/Router.js"],"sourcesContent":["export default class MatchResult {\n  constructor ({\n    input,\n    route = null,\n    url = null,\n    params = {},\n    redirect = false\n  }) {\n    this.input = input;\n    this.route = route;\n    this.params = params;\n    this.redirect = redirect;\n    this.original = null;\n    this.url = url || route.buildUrl(params);\n  }\n\n  isRedirect ({original}) {\n    this.redirect = true;\n    this.original = original;\n  }\n}\n","import Url from 'url';\nimport Querystring from 'querystring';\nimport {pathToRegexp, compile} from 'path-to-regexp';\n\nimport MatchResult from './MatchResult';\n\nfunction decodeParam ({name, value}) {\n  try {\n    return decodeURIComponent(value);\n  } catch (_) {\n    throw new Error(`Invalid value for ${name}`);\n  }\n}\n\nexport default class Route {\n  /**\n   * Represents a route\n   * @constructor\n   * @param {string} name - Name for the route.\n   * @param {string} pattern - Pattern used by path-to-regexp to match route.\n   * @param {Object} page - Page to be returned along with params for this route.\n   */\n  constructor (params) {\n    const required_params = ['name', 'pattern', 'page'];\n    for (const param of required_params) {\n      if (!(param in params)) {\n        throw new Error(`Missing route param ${param}`);\n      }\n    }\n\n    // Allow for dynamic params in routes to be used with\n    // custom redirects etc.\n    for (const [k, v] of Object.entries(params)) {\n      if (['match', 'buildUrl'].includes(k)) {\n        throw new Error(`Invalid route param ${k}`);\n      }\n      this[k] = v;\n    }\n\n    // create matcher for this route (uses path-to-regexp)\n    const options = {\n      sensitive: false,\n      strict: false,\n      end: true\n    };\n    this._param_keys = [];\n    this._matcher = pathToRegexp(this.pattern, this._param_keys, options);\n  }\n\n  /**\n  * Check whether this route matches a passed path or route.\n  * @return {MatchedRoute}\n  */\n  // you can either pass a path to match\n  match (args) {\n    const fn_name = `_match${args.url ? 'Url' : 'Route'}`;\n    return this[fn_name](args);\n  }\n\n  is (test) {\n    if (test.indexOf('/') !== -1) {\n      return !!this._matcher.exec(test);\n    } else {\n      return (this.name === test);\n    }\n  }\n\n  _matchUrl (input) {\n    const {url} = input;\n\n    const {\n      query: query_params,\n      pathname: path\n    } = Url.parse(url, true);\n\n    const match = this._matcher.exec(path);\n    if (!match) {\n      return false;\n    }\n\n    const route_params = this._getParamsFromMatch(match);\n    const params = {...route_params, ...query_params};\n\n    return new MatchResult({\n      route: this,\n      input,\n      params\n    });\n  }\n\n  // matches if\n  // 1) name matches\n  // 2) all named params are present\n  _matchRoute (input) {\n    const {route} = input;\n    const {name, params = {}} = route;\n\n    // Name of passed route must match this route's name\n    if (name !== this.name) {\n      return false;\n    }\n\n    const param_names = this._requiredParamNames();\n    const has_all_params = param_names.every((name)=> name in params);\n    if (!has_all_params) {\n      return false;\n    }\n\n    // All named params are present, its a match\n    return new MatchResult({\n      input,\n      route: this,\n      params\n    });\n  }\n\n  _getParamsFromMatch (match) {\n    const params = {};\n    const param_names = this._paramNames();\n\n    for (let i = 0; i < param_names.length; i++) {\n      // TODO: worth handling delim / repeat?\n      const {name, repeat, delimiter, optional} = this._param_keys[i];\n      const value = match[i + 1];\n      const defined = (value !== undefined);\n      let decoded = defined ? decodeParam({name, value}) : value;\n      if (repeat) {\n        decoded = decoded.split(delimiter);\n      }\n      if (defined || !optional) {\n        params[name] = decoded;\n      }\n    }\n\n    return params;\n  }\n\n  buildUrl (params = {}) {\n    let url = this._buildPath(params);\n    const query = this._buildQuery(params);\n    if (query.length) {\n      url = `${url}?${query}`;\n    }\n    return url;\n  }\n\n  _buildPath (params) {\n    const {pattern} = this;\n    const buildPath = compile(pattern);\n    return buildPath(params);\n  }\n\n  _buildQuery (params) {\n    const param_names = this._paramNames();\n\n    const query_params = {};\n    for (const [name, value] of Object.entries(params)) {\n      if (!param_names.includes(name)) {\n        query_params[name] = value;\n      }\n    }\n\n    return Querystring.stringify(query_params);\n  }\n\n  _paramNames () {\n    return this._param_keys.map((k)=> k.name);\n  }\n\n  _requiredParamNames () {\n    return this._param_keys\n      .filter((k)=> !k.optional)\n      .map((k)=> k.name);\n  }\n}\n","import type from 'type-of-is';\n\nimport Route from './Route';\nimport MatchResult from './MatchResult';\n\nexport default class Router {\n  constructor ({\n    routes,\n    redirects,\n    max_redirects = 10\n  }) {\n    this.routes = [];\n    this.addRoutes(routes);\n    this.max_redirects = max_redirects;\n\n    this.redirects = [];\n    for (const [name, test] of Object.entries(redirects)) {\n      this.redirects.push({name, test});\n    }\n\n    this.listeners = [];\n  }\n\n  addRoutes (routes) {\n    const entries = Object.entries(routes);\n    for (const [name, config] of entries) {\n      config.name = name;\n      const route = new Route(config);\n      this.routes.push(route);\n    }\n  }\n\n  getRoute (query) {\n    return this.routes.find((route)=> {\n      return Object.entries(query).every(([k, v])=> {\n        return (route[k] === v);\n      });\n    });\n  }\n\n  getRouteByName (name) {\n    const route = this.getRoute({name});\n    if (!route) {\n      throw new Error(`No route named ${name}`);\n    }\n    return route;\n  }\n\n  // match\n  // -----\n  // Checks whether there is a route matching the passed pathname\n  // If there is a match, returns the associated Page and matched params.\n  // If no match return NotFound\n  match (input) {\n    const original = this._match(input);\n    const redirect = this._checkRedirects({original});\n    if (redirect) {\n      redirect.isRedirect({original});\n      return redirect;\n    } else {\n      return original;\n    }\n  }\n\n  _match (input) {\n    input = (()=> {\n      switch (type(input)) {\n        case String:\n          if (input.indexOf('/') !== -1) {\n            return {url: input};\n          } else {\n            return {route: {name: input}};\n          }\n        case Object:\n          if (input.name) {\n            return {route: input};\n          } else {\n            return input;\n          }\n        default:\n          throw new Error('Invalid input passed to _match');\n      }\n    })();\n\n    // if passed full url, treat as redirect\n    const {url} = input;\n    if (url && url.match(/^https?:\\/\\//)) {\n      return new MatchResult({\n        redirect: true,\n        input,\n        url\n      });\n    }\n\n    let match = null;\n    for (const r of this.routes) {\n      match = r.match(input);\n      if (match) {\n        break;\n      }\n    }\n\n    return match;\n  }\n\n  _checkRedirects ({\n    original,\n    previous = null,\n    current = null,\n    num_redirects = 0,\n    history = []\n  }) {\n    const {max_redirects} = this;\n    if (num_redirects >= max_redirects) {\n      throw new Error(`Number of redirects exceeded max_redirects (${max_redirects})`);\n    }\n\n    function deepEqual (a, b) {\n      const {stringify} = JSON;\n      return (stringify(a) === stringify(b));\n    }\n\n    // if current is the same as original, then we've looped, so this shouldn't\n    // be a redirect\n    // TODO: improve cycle detection\n    if (current && previous) {\n      const same_route = (current.route === previous.route);\n      const same_params = deepEqual(current.params, previous.params);\n      if (same_route && same_params) {\n        return previous;\n      }\n    }\n\n    if (!current) {\n      current = original;\n      history = [original];\n    }\n\n    if (current.redirect) {\n      return current;\n    }\n\n    let next = false;\n    if (current && current.route.redirect) {\n      next = current.route.redirect(current);\n    }\n    if (!next) {\n      for (const {test} of this.redirects) {\n        // test returns false if no redirect is needed\n        next = test(current);\n        if (next) {\n          break;\n        }\n      }\n    }\n\n    if (next) {\n      previous = current;\n      // we got a redirect\n      current = this._match(next);\n      if (!current) {\n        throw new Error(`No match for redirect result ${next}`);\n      }\n      history.push(current);\n      num_redirects++;\n      return this._checkRedirects({original, previous, current, num_redirects, history});\n    } else if (num_redirects > 0) {\n      return current;\n    } else {\n      return false;\n    }\n  }\n\n  onChange (listener) {\n    this.listeners.push(listener);\n  }\n\n  go (input) {\n    const match = this.match(input);\n    const {url} = match;\n    for (const listener of this.listeners) {\n      listener(url);\n    }\n  }\n}\n"],"names":["MatchResult","constructor","input","route","url","params","redirect","this","original","buildUrl","isRedirect","decodeParam","name","value","decodeURIComponent","_","Error","Route","required_params","param","k","v","Object","entries","includes","_param_keys","_matcher","pathToRegexp","pattern","sensitive","strict","end","match","args","is","test","indexOf","exec","_matchUrl","query","query_params","pathname","path","Url","parse","_getParamsFromMatch","_matchRoute","_requiredParamNames","every","param_names","_paramNames","i","length","repeat","delimiter","optional","defined","undefined","decoded","split","_buildPath","_buildQuery","compile","buildPath","Querystring","stringify","map","filter","Router","routes","redirects","max_redirects","addRoutes","push","listeners","config","getRoute","find","getRouteByName","_match","_checkRedirects","type","String","r","previous","current","num_redirects","history","same_route","same_params","a","b","JSON","deepEqual","next","onChange","listener","go"],"mappings":"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"}