{"version":3,"file":"index.esm.js","sources":["../src/MatchResult.js","../src/Route.js","../src/Router.js"],"sourcesContent":["export default class MatchResult {\n  constructor ({\n    input,\n    route = null,\n    url = null,\n    params = {},\n    redirect = false\n  }) {\n    this.input = input;\n    this.route = route;\n    this.params = params;\n    this.redirect = redirect;\n    this.original = null;\n    this.url = url || route.buildUrl(params);\n  }\n\n  isRedirect ({original}) {\n    this.redirect = true;\n    this.original = original;\n  }\n}\n","import Url from 'url';\nimport Querystring from 'querystring';\nimport {pathToRegexp, compile} from 'path-to-regexp';\n\nimport MatchResult from './MatchResult';\n\nfunction decodeParam ({name, value}) {\n  try {\n    return decodeURIComponent(value);\n  } catch (_) {\n    throw new Error(`Invalid value for ${name}`);\n  }\n}\n\nexport default class Route {\n  /**\n   * Represents a route\n   * @constructor\n   * @param {string} name - Name for the route.\n   * @param {string} pattern - Pattern used by path-to-regexp to match route.\n   * @param {Object} page - Page to be returned along with params for this route.\n   */\n  constructor (params) {\n    const required_params = ['name', 'pattern', 'page'];\n    for (const param of required_params) {\n      if (!(param in params)) {\n        throw new Error(`Missing route param ${param}`);\n      }\n    }\n\n    // Allow for dynamic params in routes to be used with\n    // custom redirects etc.\n    for (const [k, v] of Object.entries(params)) {\n      if (['match', 'buildUrl'].includes(k)) {\n        throw new Error(`Invalid route param ${k}`);\n      }\n      this[k] = v;\n    }\n\n    // create matcher for this route (uses path-to-regexp)\n    const options = {\n      sensitive: false,\n      strict: false,\n      end: true\n    };\n    this._param_keys = [];\n    this._matcher = pathToRegexp(this.pattern, this._param_keys, options);\n  }\n\n  /**\n  * Check whether this route matches a passed path or route.\n  * @return {MatchedRoute}\n  */\n  // you can either pass a path to match\n  match (args) {\n    const fn_name = `_match${args.url ? 'Url' : 'Route'}`;\n    return this[fn_name](args);\n  }\n\n  is (test) {\n    if (test.indexOf('/') !== -1) {\n      return !!this._matcher.exec(test);\n    } else {\n      return (this.name === test);\n    }\n  }\n\n  _matchUrl (input) {\n    const {url} = input;\n\n    const {\n      query: query_params,\n      pathname: path\n    } = Url.parse(url, true);\n\n    const match = this._matcher.exec(path);\n    if (!match) {\n      return false;\n    }\n\n    const route_params = this._getParamsFromMatch(match);\n    const params = {...route_params, ...query_params};\n\n    return new MatchResult({\n      route: this,\n      input,\n      params\n    });\n  }\n\n  // matches if\n  // 1) name matches\n  // 2) all named params are present\n  _matchRoute (input) {\n    const {route} = input;\n    const {name, params = {}} = route;\n\n    // Name of passed route must match this route's name\n    if (name !== this.name) {\n      return false;\n    }\n\n    const param_names = this._requiredParamNames();\n    const has_all_params = param_names.every((name)=> name in params);\n    if (!has_all_params) {\n      return false;\n    }\n\n    // All named params are present, its a match\n    return new MatchResult({\n      input,\n      route: this,\n      params\n    });\n  }\n\n  _getParamsFromMatch (match) {\n    const params = {};\n    const param_names = this._paramNames();\n\n    for (let i = 0; i < param_names.length; i++) {\n      // TODO: worth handling delim / repeat?\n      const {name, repeat, delimiter, optional} = this._param_keys[i];\n      const value = match[i + 1];\n      const defined = (value !== undefined);\n      let decoded = defined ? decodeParam({name, value}) : value;\n      if (repeat) {\n        decoded = decoded.split(delimiter);\n      }\n      if (defined || !optional) {\n        params[name] = decoded;\n      }\n    }\n\n    return params;\n  }\n\n  buildUrl (params = {}) {\n    let url = this._buildPath(params);\n    const query = this._buildQuery(params);\n    if (query.length) {\n      url = `${url}?${query}`;\n    }\n    return url;\n  }\n\n  _buildPath (params) {\n    const {pattern} = this;\n    const buildPath = compile(pattern);\n    return buildPath(params);\n  }\n\n  _buildQuery (params) {\n    const param_names = this._paramNames();\n\n    const query_params = {};\n    for (const [name, value] of Object.entries(params)) {\n      if (!param_names.includes(name)) {\n        query_params[name] = value;\n      }\n    }\n\n    return Querystring.stringify(query_params);\n  }\n\n  _paramNames () {\n    return this._param_keys.map((k)=> k.name);\n  }\n\n  _requiredParamNames () {\n    return this._param_keys\n      .filter((k)=> !k.optional)\n      .map((k)=> k.name);\n  }\n}\n","import type from 'type-of-is';\n\nimport Route from './Route';\nimport MatchResult from './MatchResult';\n\nexport default class Router {\n  constructor ({\n    routes,\n    redirects,\n    max_redirects = 10\n  }) {\n    this.routes = [];\n    this.addRoutes(routes);\n    this.max_redirects = max_redirects;\n\n    this.redirects = [];\n    for (const [name, test] of Object.entries(redirects)) {\n      this.redirects.push({name, test});\n    }\n\n    this.listeners = [];\n  }\n\n  addRoutes (routes) {\n    const entries = Object.entries(routes);\n    for (const [name, config] of entries) {\n      config.name = name;\n      const route = new Route(config);\n      this.routes.push(route);\n    }\n  }\n\n  getRoute (query) {\n    return this.routes.find((route)=> {\n      return Object.entries(query).every(([k, v])=> {\n        return (route[k] === v);\n      });\n    });\n  }\n\n  getRouteByName (name) {\n    const route = this.getRoute({name});\n    if (!route) {\n      throw new Error(`No route named ${name}`);\n    }\n    return route;\n  }\n\n  // match\n  // -----\n  // Checks whether there is a route matching the passed pathname\n  // If there is a match, returns the associated Page and matched params.\n  // If no match return NotFound\n  match (input) {\n    const original = this._match(input);\n    const redirect = this._checkRedirects({original});\n    if (redirect) {\n      redirect.isRedirect({original});\n      return redirect;\n    } else {\n      return original;\n    }\n  }\n\n  _match (input) {\n    input = (()=> {\n      switch (type(input)) {\n        case String:\n          if (input.indexOf('/') !== -1) {\n            return {url: input};\n          } else {\n            return {route: {name: input}};\n          }\n        case Object:\n          if (input.name) {\n            return {route: input};\n          } else {\n            return input;\n          }\n        default:\n          throw new Error('Invalid input passed to _match');\n      }\n    })();\n\n    // if passed full url, treat as redirect\n    const {url} = input;\n    if (url && url.match(/^https?:\\/\\//)) {\n      return new MatchResult({\n        redirect: true,\n        input,\n        url\n      });\n    }\n\n    let match = null;\n    for (const r of this.routes) {\n      match = r.match(input);\n      if (match) {\n        break;\n      }\n    }\n\n    return match;\n  }\n\n  _checkRedirects ({\n    original,\n    previous = null,\n    current = null,\n    num_redirects = 0,\n    history = []\n  }) {\n    const {max_redirects} = this;\n    if (num_redirects >= max_redirects) {\n      throw new Error(`Number of redirects exceeded max_redirects (${max_redirects})`);\n    }\n\n    function deepEqual (a, b) {\n      const {stringify} = JSON;\n      return (stringify(a) === stringify(b));\n    }\n\n    // if current is the same as original, then we've looped, so this shouldn't\n    // be a redirect\n    // TODO: improve cycle detection\n    if (current && previous) {\n      const same_route = (current.route === previous.route);\n      const same_params = deepEqual(current.params, previous.params);\n      if (same_route && same_params) {\n        return previous;\n      }\n    }\n\n    if (!current) {\n      current = original;\n      history = [original];\n    }\n\n    if (current.redirect) {\n      return current;\n    }\n\n    let next = false;\n    if (current && current.route.redirect) {\n      next = current.route.redirect(current);\n    }\n    if (!next) {\n      for (const {test} of this.redirects) {\n        // test returns false if no redirect is needed\n        next = test(current);\n        if (next) {\n          break;\n        }\n      }\n    }\n\n    if (next) {\n      previous = current;\n      // we got a redirect\n      current = this._match(next);\n      if (!current) {\n        throw new Error(`No match for redirect result ${next}`);\n      }\n      history.push(current);\n      num_redirects++;\n      return this._checkRedirects({original, previous, current, num_redirects, history});\n    } else if (num_redirects > 0) {\n      return current;\n    } else {\n      return false;\n    }\n  }\n\n  onChange (listener) {\n    this.listeners.push(listener);\n  }\n\n  go (input) {\n    const match = this.match(input);\n    const {url} = match;\n    for (const listener of this.listeners) {\n      listener(url);\n    }\n  }\n}\n"],"names":["MatchResult","route","url","params","redirect","this","input","original","buildUrl","isRedirect","decodeParam","name","value","decodeURIComponent","_","Error","Route","param","Object","entries","k","v","includes","_param_keys","_matcher","pathToRegexp","pattern","sensitive","strict","end","match","args","is","test","indexOf","exec","_matchUrl","Url","parse","query_params","query","pathname","_getParamsFromMatch","_matchRoute","_requiredParamNames","every","param_names","_paramNames","i","length","repeat","delimiter","optional","defined","undefined","decoded","split","_buildPath","_buildQuery","compile","buildPath","Querystring","stringify","map","filter","Router","routes","redirects","max_redirects","addRoutes","push","listeners","config","getRoute","find","getRouteByName","_match","_checkRedirects","type","String","b","previous","current","num_redirects","history","same_route","same_params","JSON","next","onChange","listener","go"],"mappings":"8lCAAqBA,IAAAA,aACnB,sBAEEC,MAAAA,aAAQ,WACRC,IAAAA,aAAM,WACNC,OAAAA,aAAS,SACTC,SAAAA,gBAEAC,KAAKC,QANLA,MAOAD,KAAKJ,MAAQA,EACbI,KAAKF,OAASA,EACdE,KAAKD,SAAWA,EAChBC,KAAKE,SAAW,KAChBF,KAAKH,IAAMA,GAAOD,EAAMO,SAASL,sBAGnCM,WAAA,gBAAaF,IAAAA,SACXF,KAAKD,UAAW,EAChBC,KAAKE,SAAWA,QCZpB,SAASG,SAAcC,IAAAA,KAAMC,IAAAA,MAC3B,IACE,OAAOC,mBAAmBD,GAC1B,MAAOE,GACP,UAAUC,2BAA2BJ,IAIpBK,IAAAA,aAQnB,WAAab,GAEX,IADA,UAAwB,CAAC,OAAQ,UAAW,uBACP,CAAhC,IAAMc,OACT,KAAMA,KAASd,GACb,UAAUY,6BAA6BE,GAM3C,cAAqBC,OAAOC,QAAQhB,kBAAS,YAAjCiB,OAAGC,OACb,GAAI,CAAC,QAAS,YAAYC,SAASF,GACjC,UAAUL,6BAA6BK,GAEzCf,KAAKe,GAAKC,EASZhB,KAAKkB,YAAc,GACnBlB,KAAKmB,SAAWC,EAAapB,KAAKqB,QAASrB,KAAKkB,YANhC,CACdI,WAAW,EACXC,QAAQ,EACRC,KAAK,+BAWTC,MAAA,SAAOC,GAEL,sBADyBA,EAAK7B,IAAM,MAAQ,UACvB6B,MAGvBC,GAAA,SAAIC,GACF,OAA2B,IAAvBA,EAAKC,QAAQ,OACN7B,KAAKmB,SAASW,KAAKF,QAEftB,OAASsB,KAI1BG,UAAA,SAAW9B,SAML+B,EAAIC,MALMhC,EAAPJ,KAKY,GAFVqC,IAAPC,MAIIV,EAAQzB,KAAKmB,SAASW,OAH1BM,UAIF,IAAKX,EACH,SAGF,IACM3B,SADeE,KAAKqC,oBAAoBZ,IACVS,GAEpC,WAAWvC,EAAY,CACrBC,MAAOI,KACPC,MAAAA,EACAH,OAAAA,OAOJwC,YAAA,SAAarC,OACJL,EAASK,EAATL,QACqBA,EAAfE,OAAAA,aAAS,KAGtB,OAH4BF,EAArBU,OAGMN,KAAKM,QAIEN,KAAKuC,sBACUC,MAAM,SAAClC,UAAQA,KAAQR,SAM/CH,EAAY,CACrBM,MAAAA,EACAL,MAAOI,KACPF,OAAAA,OAIJuC,oBAAA,SAAqBZ,GAInB,IAHA,IAAM3B,EAAS,GACT2C,EAAczC,KAAK0C,cAEhBC,EAAI,EAAGA,EAAIF,EAAYG,OAAQD,IAAK,OAEC3C,KAAKkB,YAAYyB,GAAtDrC,IAAAA,KAAMuC,IAAAA,OAAQC,IAAAA,UAAWC,IAAAA,SAC1BxC,EAAQkB,EAAMkB,EAAI,GAClBK,OAAqBC,IAAV1C,EACb2C,EAAUF,EAAU3C,EAAY,CAACC,KAAAA,EAAMC,MAAAA,IAAUA,EACjDsC,IACFK,EAAUA,EAAQC,MAAML,KAEtBE,GAAYD,IACdjD,EAAOQ,GAAQ4C,GAInB,OAAOpD,KAGTK,SAAA,SAAUL,YAAAA,IAAAA,EAAS,IACjB,IAAID,EAAMG,KAAKoD,WAAWtD,GACpBqC,EAAQnC,KAAKqD,YAAYvD,GAI/B,OAHIqC,EAAMS,SACR/C,EAASA,MAAOsC,GAEXtC,KAGTuD,WAAA,SAAYtD,GAGV,OADkBwD,EADAtD,KAAXqB,QAEAkC,CAAUzD,MAGnBuD,YAAA,SAAavD,GAIX,IAHA,IAAM2C,EAAczC,KAAK0C,cAEnBR,EAAe,SACOrB,OAAOC,QAAQhB,kBAAS,YAAxCQ,OAAMC,OACXkC,EAAYxB,SAASX,KACxB4B,EAAa5B,GAAQC,GAIzB,OAAOiD,EAAYC,UAAUvB,MAG/BQ,YAAA,WACE,YAAYxB,YAAYwC,IAAI,SAAC3C,UAAKA,EAAET,UAGtCiC,oBAAA,WACE,YAAYrB,YACTyC,OAAO,SAAC5C,UAAMA,EAAEgC,WAChBW,IAAI,SAAC3C,UAAKA,EAAET,aCvKEsD,aACnB,kBACEC,IAAAA,OACAC,IAAAA,cACAC,cAAAA,aAAgB,KAEhB/D,KAAK6D,OAAS,GACd7D,KAAKgE,UAAUH,GACf7D,KAAK+D,cAAgBA,EAErB/D,KAAK8D,UAAY,GACjB,cAA2BjD,OAAOC,QAAQgD,kBAAY,YACpD9D,KAAK8D,UAAUG,KAAK,CAAC3D,UAAMsB,YAG7B5B,KAAKkE,UAAY,8BAGnBF,UAAA,SAAWH,GAET,IADA,UAAgBhD,OAAOC,QAAQ+C,kBACO,YAApBM,OAChBA,EAAO7D,UACP,IAAMV,EAAQ,IAAIe,EAAMwD,GACxBnE,KAAK6D,OAAOI,KAAKrE,OAIrBwE,SAAA,SAAUjC,GACR,YAAY0B,OAAOQ,KAAK,SAACzE,GACvB,OAAOiB,OAAOC,QAAQqB,GAAOK,MAAM,YACjC,OAAQ5C,sBAKd0E,eAAA,SAAgBhE,GACd,IAAMV,EAAQI,KAAKoE,SAAS,CAAC9D,KAAAA,IAC7B,IAAKV,EACH,UAAUc,wBAAwBJ,GAEpC,OAAOV,KAQT6B,MAAA,SAAOxB,GACL,IAAMC,EAAWF,KAAKuE,OAAOtE,GACvBF,EAAWC,KAAKwE,gBAAgB,CAACtE,SAAAA,IACvC,OAAIH,GACFA,EAASK,WAAW,CAACF,SAAAA,IACdH,GAEAG,KAIXqE,OAAA,SAAQtE,GAAO,IAqBNJ,GApBPI,EAAS,WACP,OAAQwE,EAAKxE,IACX,KAAKyE,OACH,OAA4B,IAAxBzE,EAAM4B,QAAQ,KACT,CAAChC,IAAKI,GAEN,CAACL,MAAO,CAACU,KAAML,IAE1B,KAAKY,OACH,OAAIZ,EAAMK,KACD,CAACV,MAAOK,GAERA,EAEX,QACE,UAAUS,MAAM,mCAfb,IAoBFb,IACP,GAAIA,GAAOA,EAAI4B,MAAM,gBACnB,WAAW9B,EAAY,CACrBI,UAAU,EACVE,MAAAA,EACAJ,IAAAA,IAKJ,IADA,MAAI4B,EAAQ,SACIzB,KAAK6D,yBACnBpC,UAAUA,MAAMxB,MAMlB,OAAOwB,KAGT+C,gBAAA,gBAYyBG,EACdlB,EAZTvD,IAAAA,aACA0E,SAAAA,aAAW,WACXC,QAAAA,aAAU,WACVC,cAAAA,aAAgB,QAChBC,QAAAA,aAAU,KAEHhB,EAAiB/D,KAAjB+D,cACP,GAAIe,GAAiBf,EACnB,UAAUrD,qDAAqDqD,OAWjE,GAAIc,GAAWD,EAAU,CACvB,IAAMI,EAAcH,EAAQjF,QAAUgF,EAAShF,MACzCqF,GAVeN,EAUyBC,EAAS9E,QAThD2D,EAAayB,KAAbzB,WASuBoB,EAAQ/E,UARb2D,EAAUkB,IASnC,GAAIK,GAAcC,EAChB,OAAOL,EASX,GALKC,IACHA,EAAU3E,EACV6E,EAAU,CAAC7E,IAGT2E,EAAQ9E,SACV,OAAO8E,EAGT,IAAIM,GAAO,EAIX,GAHIN,GAAWA,EAAQjF,MAAMG,WAC3BoF,EAAON,EAAQjF,MAAMG,SAAS8E,KAE3BM,EACH,cAAqBnF,KAAK8D,4BAExBqB,GAAOvD,UAFGA,MAEEiD,MAOhB,GAAIM,EAAM,CAIR,GAHAP,EAAWC,IAEXA,EAAU7E,KAAKuE,OAAOY,IAEpB,UAAUzE,sCAAsCyE,GAIlD,OAFAJ,EAAQd,KAAKY,GACbC,SACYN,gBAAgB,CAACtE,SAAAA,EAAU0E,SAAAA,EAAUC,QAAAA,EAASC,cAAAA,EAAeC,QAAAA,WAChED,EAAgB,GAClBD,KAMXO,SAAA,SAAUC,GACRrF,KAAKkE,UAAUD,KAAKoB,MAGtBC,GAAA,SAAIrF,GAGF,IAFA,MACOJ,EADOG,KAAKyB,MAAMxB,GAClBJ,QACgBG,KAAKkE,2BAC1BmB,WAASxF"}